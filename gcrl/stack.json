[
{"title": "Документация пользователя", "posts": [{"votes": "0", "text": "Какие способы создания справки для пользователя программы вы знаете?\n"}, {"votes": "1", "text": "Можно использовать HTML-страницы. Браузеры сейчас установлены на большей части компов.\n"}, {"votes": "1", "text": "Уже ответил \n"}, {"votes": "1", "text": "Какие способы создания справки для пользователя программы вы знаете?\nДля пользователя? Открываете любой текстовый редактор и набиваете. В любом случае, первично - \"мясо\", затравка документа. А потом можно уже навернуть красивости: оглавление, форматирование, картинки и пр. Причем вариантов как сохранить документацию масса: начиная от обычных txt-файлов, кончая навороченными CHM и PDF. Посмотрите как сделано у других и решите, что лучше подходит Вам лично. Напомню, что стандартная справка в Windows реализуется через HLP-файлы (уже уходят в прошлое) и CHM-файлы (по сути - архив с HTML-документами). PDF же очень легко получить из RTF, DOC или ODT (OpenOffice)-документа.\nВ автоматическом же режиме удастся сделать \"документацию для программиста\": описание внутреннего мира программы, который нужен при ее доработке. Да и то это возможно только при комментировании кода по определенному стандарту, чтобы эти комментарии легко было найти и обработать автоматизированными утилитами.\n"}]},
{"title": "Как задать периодическое выполнение скрипта на Ubuntu? [дубликат]", "posts": [{"votes": "0", "text": "\nНужно снимать дамп базы данных и высылать его на почту раз в неделю.\n"}, {"votes": "0", "text": "Для подобных задач существует специальный демон - cron. Для его настройки используют команду crontab. Например, чтобы раз в минуту писать в файл текстовую фразу достаточно\n"}]},
{"title": "Область видимости (С++)", "posts": [{"votes": "1", "text": "Я хочу объявить переменную, у которой область - видимости один файл. В языке С это легко решить, используя ключевое слово static. Как сделать подобное на языке С++?\n"}, {"votes": "6", "text": "В С++ данный вопрос решается с помощью безымянного пространства имен. Поясню на примере.\n```\n// C код\nstatic int someVar = 0;\nstatic char * ptr = NULL;\n\n// С++ код\nnamespace {\n    int someVar = 0;\n    char * ptr = NULL;\n}\n```\nПоскольку пространство имен не имеет имени, его нельзя определить в другом файле исходного кода, а следовательно и обратиться к переменным, объявленным внутри него.\n"}]},
{"title": "Работа с командной строкой  в WPF", "posts": [{"votes": "1", "text": "Сейчас в моем проекте доступ к аргументам командной строки организован так: \n```\nApplication.Current.Properties[\"value\"].ToString())\n```\nЯ считаю, что если хранить аргументы в статическом объекте, то доступ можно упростить, и он будет выглядеть так: \n```\nMyProgramm.App.value\n```\nМеня интересует, как правильнее решить эту задачу?\n"}, {"votes": "1", "text": "Я обычно делаю следующим образом.\n\nТаким образом сочетается лёгкая расширяемость с преимуществами жёсткой типизации.\n"}, {"votes": "0", "text": "На мой взгляд, лучше оставить словарь (расширяемость). Для упрощения работы с длинными именами рекомендую использовать псевдонимы. В данном случае, лучше использовать перечисление, т.е создается перечисление или класс со статическими полями, которые являются идентификаторами в словаре. После этого код может выглядеть так:\n```\n// Обращение к словарю\nApplication.Current.Properties{CmdLineKeys.Value].ToString())\n```\nЕсли поле \n"}]},
{"title": "Просмотр ассемблерного кода в GDB", "posts": [{"votes": "1", "text": "Как в GDB просмотреть ассемблерный код функции? Например, для кода:\n```\nvoid main() {\n}\n```\n"}, {"votes": "0", "text": "Это можно сделать командой disassemble (disas):\n```\n(gdb) disassemble main\nDump of assembler code for function main:\n   0x08048394 <+0>: push   %ebp\n   0x08048395 <+1>: mov    %esp,%ebp\n   0x08048397 <+3>: pop    %ebp\n   0x08048398 <+4>: ret    \nEnd of assembler dump.\n```\n"}]},
{"title": "Влияние словарей JavaScript на производительность", "posts": [{"votes": "7", "text": "Я привык добавлять словари в код для создания пространства имен:\n```\nvar namespace = {\n    // Какой-то код\n    somefunc: function () { },\n\n    // Какие-то данные\n    somedata: undefined\n}\n```\nПотому что данные и функции удобно разделяются:\n```\nnamespace.somefunc();\nnamespace.somedata = \"\";\n```\nНо мне не совсем ясно, как это искусственное разделение влияет на производительность? Насколько затормаживаются вызовы и обращения?\n"}, {"votes": "8", "text": "Почти не влияет. Всего лишь 1 доп. поиск в map (все объекты в js являются картами, или map. Вызов namespace.somedata - ни что иное, как window['namespace']['somedata'], против window['somedata'] без нс). Это самая элементарная операция, их масса во время выполнения кода.\nЗато плюсы (в больших скриптах не засоряется глобальное пространство имен) очевидны.\n"}]},
{"title": "Производительность LINQ", "posts": [{"votes": "11", "text": "Есть массив целых чисел. Нужно подсчитать количество элементов больше пяти.\n```\nint[] numbers = { 1, 3, 5, 7, 3, 2, 5, 7 };\n```\nВариант с циклом:\n```\nint count = 0;\nforeach (int n in numbers) {\n    if (n > 5) {\n        count++;\n    }\n}\n```\nВариант с LINQ:\n```\nint count = numbers.Count(n => n > 5);\n```\nЧто выгодней с точки зрения производительности и насколько существенна разница?\n"}, {"votes": "22", "text": "Предыдущий ответ не имеет никакого отношения к реальности. Хотелось бы примера с подтверждением наличия случая, когда \n```\nint count = 0;\n//int[] numbers = { 1, 3, 5, 7, 3, 2, 5, 7 };\nint N = 100000;\nint RUN_COUNT = 10000;\nRandom r = new Random();\nint[] numbers = Enumerable.Range(1, N).Select((x) => r.Next()).ToArray();\n\n\nDateTime started = DateTime.Now;\nfor (int i = 0; i < RUN_COUNT; i++)\n{\n    count = 0;\n    //foreach (int n in numbers)\n    for (int j = 0; j < numbers.Length; j++ )\n    {\n        if (numbers[j] > 5)\n        //if (n  > 5)\n        {\n            count++;\n        }\n    }\n}\n\nDateTime end = DateTime.Now;\nTimeSpan tspan = end - started;\n\ndouble iteration_time_simple = (double)tspan.TotalMilliseconds /  1000;           \n//---------------------------------------------------------\nstarted = DateTime.Now;\nfor (int i = 0; i < RUN_COUNT; i++)\n{\n     count = numbers.Count(n => n > 5);\n}\n\nend = DateTime.Now;\ntspan = end - started;\n\ndouble iteration_time_linq = (double)tspan.TotalMilliseconds /  1000;\n\n\nConsole.WriteLine(\"linq/simple: {0}\", iteration_time_linq / iteration_time_simple);\nConsole.WriteLine(\"simple time: {0} seconds\", iteration_time_simple);\nConsole.WriteLine(\"linq  time: {0} seconds\", iteration_time_linq); \n```\nНа выходе получаем:\n```\nlinq/simple: 2.612\nsimple time: 7.8125 seconds\nlinq  time: 20.40625 seconds\n```\nТо есть вариант с \nМое резюме: использовать \n"}, {"votes": "-6", "text": "LINQ - гарантированно быстрее, чем любые вручную имплементированные циклы. Он раскладывается в более компактный ассемблер.\nВ конкретном примере врядли можно заметить разницу, но при работе с большим количеством текстовых данных, производительность LINQ будет заметна.\nА, в общем, по LINQ: ведь качество кода (в частности, его читабельность) не менее важно, чем производительность. Подумайте, что будет легче поддерживать, 1й или 2й вариант?\n"}]},
{"title": "Как вывести размер папки из терминала в Ubuntu?", "posts": [{"votes": "16", "text": ""}, {"votes": "24", "text": "\nПример вывода для папки с вложенными папками:\n669M    idea-IC-162.1812.17\n"}, {"votes": "18", "text": "Получить размер папки можно с помощью команды \nКоманда.\n```\ndu -h --max-depth=1 | grep папка\n```\nВывод.\n```\n158M    ./папка\n```\n"}, {"votes": "14", "text": "Можно еще проще\n```\ndu -h <имя-директории>\n```\n"}]},
{"title": "Изменение размера изображения", "posts": [{"votes": "1", "text": "Как нарисовать изображение UIImage, увеличенное в N раз?\n"}, {"votes": "1", "text": "Можно вот так:\n```\nCGFloat factor = 2.5;   // во сколько раз изменяем размер\nCGSize targetSize = CGSizeMake(image.size.width * factor, image.size.height * factor);\nUIGraphicsBeginImageContext(targetSize);\nfloat x = (targetSize.width - image.size.width * factor) / 2;\nfloat y = (targetSize.height - image.size.height * factor) / 2;\nCGRect rect = CGRectMake(x, y, image.size.width * factor, image.size.height * factor);\n[image drawInRect:rect];\nUIImage *result = UIGraphicsGetImageFromCurrentImageContext();\nUIGraphicsEndImageContext();\nreturn result;\n```\n"}, {"votes": "1", "text": "Должно помочь:\n```\n//  ==============================================================\n//  resizedImage\n//  ==============================================================\n// Return a scaled down copy of the image.\n\nUIImage* resizedImage(UIImage *inImage, CGRect thumbRect)\n{\n    CGImageRef          imageRef = [inImage CGImage];\n    CGImageAlphaInfo    alphaInfo = CGImageGetAlphaInfo(imageRef);\n\n    // There's a wierdness with kCGImageAlphaNone and CGBitmapContextCreate\n    // see Supported Pixel Formats in the Quartz 2D Programming Guide\n    // Creating a Bitmap Graphics Context section\n    // only RGB 8 bit images with alpha of kCGImageAlphaNoneSkipFirst, kCGImageAlphaNoneSkipLast, kCGImageAlphaPremultipliedFirst,\n    // and kCGImageAlphaPremultipliedLast, with a few other oddball image kinds are supported\n    // The images on input here are likely to be png or jpeg files\n    if (alphaInfo == kCGImageAlphaNone)\n        alphaInfo = kCGImageAlphaNoneSkipLast;\n\n    // Build a bitmap context that's the size of the thumbRect\n    CGContextRef bitmap = CGBitmapContextCreate(\n                NULL,\n                thumbRect.size.width,       // width\n                thumbRect.size.height,      // height\n                CGImageGetBitsPerComponent(imageRef),   // really needs to always be 8\n                4 * thumbRect.size.width,   // rowbytes\n                CGImageGetColorSpace(imageRef),\n                alphaInfo\n        );\n\n    // Draw into the context, this scales the image\n    CGContextDrawImage(bitmap, thumbRect, imageRef);\n\n    // Get an image from the context and a UIImage\n    CGImageRef  ref = CGBitmapContextCreateImage(bitmap);\n    UIImage*    result = [UIImage imageWithCGImage:ref];\n\n    CGContextRelease(bitmap);   // ok if NULL\n    CGImageRelease(ref);\n\n    return result;\n}\n```\n"}]},
{"title": "Как сделать закругленные углы в html", "posts": [{"votes": "3", "text": ""}, {"votes": "4", "text": "Если у всех четырёх углов нужен одинаковый радиус, то можно написать одно свойство вместо четырёх:\n```\n-webkit-border-radius: 2px;\n-moz-border-radius: 2px;\nborder-radius: 2px;\n```\nПоследняя строчка для Оперы и ИЕ9.\n"}, {"votes": "2", "text": "Для решения этой проблемы можно воспользоваться css стилями.\nChrome, Safari.\n```\n-webkit-border-bottom-right-radius: 5px;\n-webkit-border-top-right-radius: 5px;\n-webkit-border-bottom-left-radius: 5px;\n-webkit-border-top-left-radius: 5px;\n```\nFirefox.\n```\n-moz-border-radius-bottomright: 5px;\n-moz-border-radius-topright: 5px;\n-moz-border-radius-bottomleft: 5px;\n-moz-border-radius-topleft: 5px;\n```\nСовременный вариант для всех браузеров: \n"}, {"votes": "1", "text": "В свое время искал универсальное решение данной проблемы для всех браузеров, многие предлагали разместить в углах картинки с изображениями закруглений необходимого радиуса.\n"}, {"votes": "1", "text": "Всего существует 3 варианта.\n1-й: (от Expert)\n```\n-webkit-border-radius: 2px;\n-moz-border-radius: 2px;\nborder-radius: 2px;\n```\n2-й: (от Евген)\n```\nСпрайт с четырьями углами, положение задается через background-position\n```\n3-й: (самый старый способ)\n```\n<div class=\"b1\"></div>\n<div class=\"b2\"></div>\n<div class=\"b3\"></div>\n<div class=\"b4\"></div>\n```\nГде классы имеют последовательное уменьшение отступов слевой и справой стороны.\n"}, {"votes": "0", "text": "сокращенный вариант \n"}]},
{"title": "Как задать функцию в коде на C++, так чтобы ее можно было вызвать из кода на C?", "posts": [{"votes": "0", "text": ""}, {"votes": "4", "text": "Нужно предварить объявление функции в коде на C++ модификатором extern \"C\". Например, так.\n```\n/* Объявление */\nextern \"C\" void execute();\n\n/* Определение */\nvoid execute() {\n}\n```\n"}, {"votes": "4", "text": "Если нужно использовать один и тот же заголовочный файл для C и C++ кода, можно обернуть определения функций таким образом.\n```\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nvoid doFirst();\nvoid doSecond();\n\n#ifdef __cplusplus\n}\n#endif\n```\nЭто работает, потому что макрос \n"}]},
{"title": "Как поменять права на файл или директорию в Linux/Unix?", "posts": [{"votes": "0", "text": ""}, {"votes": "3", "text": "Необходимо выполнить команду в терминале \n```\nchmod права [флаги] /путь/до/директории/или/файла\n```\nДля рекурсивного применения используем флаг -R.\n"}, {"votes": "0", "text": "Как Выше было сказано - chmod- ом\nЕсли для группы пользователей, то chown\n"}]},
{"title": "Необычная конструкция if в C/С++", "posts": [{"votes": "15", "text": "Сегодня увидел странную конструкцию if в коде:\n```\n#define ERROR_OK 0L\n\nint foo();\n\n// ...\nif (ERROR_OK == foo() != ERROR_OK) \n{\n    // ...\n}\nelse\n{\n    // ...\n}\n```\nТак до конца и не понял, почему этот код работает и при каких значения функция выполняется. Понял, что если foo() вернет 0, то будет выполнена ветка внутри if. Помогите полностью разобраться.\n"}, {"votes": "20", "text": "Ну, всё довольно просто. Давайте разбирать по кускам.\n1) Выполняется сравнение \n2) Результат предыдущего вычисления (т.е. \n\nСоответственно, если считать, что \n"}, {"votes": "7", "text": "Код эквивалентен !foo().\nСинтаксис странный, но корректный.\n"}, {"votes": "6", "text": "Значение условного выражения в секции if будет истинным всегда, когда функция foo() будет возвращать 0, независимо от того, чему равен ERROR_OK. \n"}, {"votes": "4", "text": "Необычного и странного в конструкции ничего нет!\nЧтобы не путаться, есть простое правило: выражение в скобках может возвращать либо true либо false. Если выражение даёт true, то выполняется то, что находится сразу после закрывающейся круглой скобки.\nА само выражение в скобках разбирается согласно утверждённому приоритету операторов.\n"}, {"votes": "-2", "text": "Приоритет у (==) и (! =) одинаковый. Читается с лево на право. 0==х!=0 эквивалентно (0==х)!=0. Сначала происходит проверка на равенство затем полученное значение которое может быть равно 1 или 0(истина или ложь) сравнивается со значением 0.Такая конструкция при условии что все три операнда разные имеет смысл. В шапке темы это не так. Поэтому я называю это семантической ошибкой. Масло масленное. ERROR_OK в свою очередь не может быть ==1 потому что он задефинен с вполне определённым значением. #define ERROR_OK 0L. Тоесть ноль. Или не так?\n```\n//Что и требовалось доказать. \n#include<stdio.h>\n#define ABC 0L\n\nint main(void)\n{\nint z, x=5, y=100;\nif (ABC==0!=ABC)// если 1!=0 true\n    z=x*y;\nelse if(ABC==1!=ABC)// если 0!=0 false\n    z=x+y;\nelse\n    z=y-x;\n    printf(\"z=%d\", z);\n    return 0;\n}\n//Вывод: z=500\n\n/* Ок. Разворачиваем int foo()\nОба варианта условия if() дают\nидентичный результат*/\n#include<stdio.h> \n#define ABC 0L\n\nint foo();\n\nint main(void) \n{ \nint z,s,x, y=3;\nfor(x=-3;x<4;x++)\n{\nz=foo(x, y);\n//if (ABC==foo(x, y)!=ABC)//Семантическая ошибка. \nif (ABC==foo(x, y))//Более здравая конструкция?\n    printf(\"%2d %d %d\\n\", x, y, z); \nelse\n{\n    s=y+10000;\n    printf(\"%6d\\n\", s);\n}\n}\nreturn 0; \n}\n\nint foo(int p, int q)\n{\nint g=p/q;\nreturn g;\n}\nВывод:\n  10003\n -2 3 0\n -1 3 0\n  0 3 0\n  1 3 0\n  2 3 0\n  10003\n```\n"}]},
{"title": "Как получить список ip адресов всех активных сетевых адаптеров в Linux/Unix?", "posts": [{"votes": "1", "text": ""}, {"votes": "5", "text": "Для этого необходимо открыть терминал и выполнить команду \n```\nifconfig\n```\n"}, {"votes": "5", "text": "```\nip addr list\n```\n"}, {"votes": "1", "text": "```\nifconfig | grep -v 127.0.0.1 | grep -v lo | awk '/flags/ {printf \"Interface \"$1\" \"} /inet/ {printf $2\" \"} /status/ {printf $2\"\\n\"}'\n```\n"}, {"votes": "1", "text": "```\nifconfig -a\n```\n"}]},
{"title": "В чем суть отличия между ссылочными и значимыми типами данных в C#?", "posts": [{"votes": "9", "text": ""}, {"votes": "13", "text": "Основное различие между ссылочными и значимыми типами данных — смысл равенства и копирования.\nДля значимых типов при копировании вы получаете новый экземпляр, содержащий \n```\nPoint p1 = new Point(1, 2);\nPoint p2 = p1; // (1, 2)\np1.X = 100;\n// p2.X всё ещё равно 1\n```\nДля ссылочных типов, копирование даёт вам новую \n```\nXElement e1 = new XElement(\"test\") { Value = \"hello\" };\nXElement e2 = e1;\ne1.Value = \"goodbye\";\n// e2.Value стало равно \"goodbye\"\n```\nТеперь, равенство. Одинаковые экземпляры типов-значений, не зависимо от того, являются ли они копиями одного общего объекта или нет, являются равными. Экземпляры ссылочных типов, даже если они содержат одинаковые данные, являются разными.\n```\nPoint p1 = new Point(1, 2), p2 = new Point(1, 2);\n// p1 == p2\n```\n```\nXElement e1 = new XElement(\"test\") { Value = \"hello\" },\n         e2 = new XElement(\"test\") { Value = \"hello\" };\n// e1 != e2\n```\nМожно сказать, что объекты ссылочных типов обладают индивидуальностью, а объекты значимых типов — нет.\n\nРазумеется, семантику сравнения можно кастомизировать, перегрузив оператор сравнения (и/или реализовав интерфейс \n\nВсе остальные отличия являются лишь следствиями этих, главных отличий. То, что переменные ссылочного типа в Майкрософтовской реализации хранят внутри ссылку, есть по сути деталь имплементации. То, что экземпляры значимых типов \n\nЕсли вы выбираете, использовать для вашего объекта структуру (значимый тип) или класс (ссылочный тип), задайте себе вопрос: являются ли два объекта с одинаковыми данными одним и тем же, или разными? Если это, к примеру, объекты, представляющие человека, и в данных у вас его имя, фамилия и возраст, то имеет смысл использовать класс: ведь два человека с одинаковыми именами всё ещё не являются одним и тем же человеком.\nА если это, например, объект, представляющий рациональную дробь, то нету смысла разделять различные экземпляры дроби 3/8, так что тут уместно воспользоваться структурой.\n"}, {"votes": "1", "text": "Например, если присвоить переменной объект ссылочного типа, то в этой переменной будет только ссылка указывающая на обьект, а не само значение. А если присвоить объект значимого типа, то он скопируется.\n"}, {"votes": "0", "text": "Значимые типы хранят значение, а ссылочные - ссылку на значение.\n```\nclass ByRef\n{\n    public byte Value { get; set; }\n}\n\nstruct ByVal {\n    public byte Value { get; set; }\n}\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        ByRef byRef = new ByRef { Value = 0 };\n        ByVal byVal = new ByVal { Value = 0 };\n    }\n}\n```\nВ этом коде и byRef, и byVal создаются как локальные переменные метода Main на стеке. Переменная byVal содержит значение Value, а переменная byRef содержит ссылку на значение Value, хранящееся на куче. \n"}]},
{"title": "Сортировка списка", "posts": [{"votes": "2", "text": "Класс точка\n```\npublic class Point\n{\n    public int X { get; set; }\n    public int Y { get; set; }\n\n    public int distanse()\n    {\n        return this.X * this.X + this.Y * this.Y;\n    }\n}\n```\nи список точек\n```\nList<Point> points;\n```\nКак сортировать points по distanse?\n"}, {"votes": "4", "text": "Твой класс должен реализовывать интерфейс IComparable, то есть:\n```\npublic class Point : IComparable<Point>\n{    \n    public int X { get; set; }\n    public int Y { get; set; }\n\n    public int distanse()\n    {\n        return this.X * this.X + this.Y * this.Y;\n    }\n\n    // Реализация интерфейса\n    public int CompareTo(Point p)\n    {\n        return this.distanse() - p.distance();\n    }    \n}\n```\nЕсли сортировка в коде используется единожды, можно воспользоваться анонимным делегатом, без модифицирования класса: \n```\nList <Point> points = new List <Point>();\npoints.Sort( delegate(Point p1, Point p2){ return p1.distanse() - p2.distanse(); } );\n```\n\n"}, {"votes": "4", "text": "Используя LINQ (не меняя класс):\n```\nList<Point> sorted = points.OrderBy(p => p.distanse()).ToList();\n```\n"}, {"votes": "2", "text": "Если не хочешь менять свой класс, тожно cделать так:\n```\npublic class PointComparer : IComparer<Point> {\n    public int Compare(Point a, Point b) {\n        return a.distanse() - b.distanse();\n    }\n}\n```\nа сортировать так:\n```\npoints.Sort(new PointComparer());\n```\n"}, {"votes": "2", "text": "Еще вариант, не требующий изменения класса:\n```\npoints.Sort((a, b) => a.distance() - b.distance());\n```\n"}]},
{"title": "Метод equals() в Java", "posts": [{"votes": "16", "text": "Как правильно переопределить метод \n"}, {"votes": "18", "text": " при проектировании метода \n\nТакже стоит обратить внимание на то, что аргументом метода \nМетод \n"}, {"votes": "12", "text": "Приведу пример, по которому все будет понятно, также не надо забывать, что при переопределении метода equals() необходимо переопределить метод hashCode(). Если метод equals() возвращает истину для двух объектов, то их хэш-код должен быть одинаковым. Обратное утверждение не верно.\n```\nTestClass {\n    private int id;\n    public boolean equals(Object other)\n    {\n        if(!super.equals(other)) return false;\n        if (this == other) return true;\n        if (other == null) return false;\n        if(this.getClass() != other.getClass()) return false;\n        TestClass otherObj = (TestClass)other;\n        return this.id == otherObj.id;\n    }\n    public int hashCode()\n    {   \n        return 76+133*id;\n    }\n}\n```\n"}, {"votes": "5", "text": "Имеем простой класс такой структуры:\n```\nclass A {\n    final B someNonNullField;\n    C someOtherField;\n    int someNonStateField;\n  }\n```\nТакой метод определения метода equals будет подойдет во многих ситуациях:\n```\npublic boolean equals(Object other) {\n    // Не строго необходимо, но обычно неплохо для оптимизации\n    if (this == other)\n      return true;\n    if (!(other instanceof A))\n      return false;\n    A otherA = (A) other;\n    return \n      (someNonNullField.equals(otherA.someNonNullField))\n        && ((someOtherField == null) \n            ? otherA.someOtherField == null \n            : someOtherField.equals(otherA.someOtherField)));\n  }\n```\nДействительно нельзя забывать о методе hashCode. сойдет такая его реализация:\n```\npublic int hashCode() { \n    int hash = 1;\n    hash = hash * 31 + someNonNullField.hashCode();\n    hash = hash * 31 \n                + (someOtherField == null ? 0 : someOtherField.hashCode());\n    return hash;\n  }\n```\nБолее подробно написано с этой \n"}, {"votes": "4", "text": "Вариант использования equals при наследовании. Пусть есть класс точка\n```\npublic class Point {\n    private int x;\n    private int y;\n\n    public Point(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public boolean equals(Object obj) {\n        if (obj == null)\n            return false;\n        // проверка на случай, если сравнение с самим собой\n        if (obj == this)\n            return true;\n        if (obj.getClass() == this.getClass()) {\n            Point point = (Point) obj;\n            if (point.x == this.x && point.y == this.y)\n                return true;\n        }\n        return false;\n    }\n}\n```\nТеперь пришла в голову мысль написать расширение Point3D и для него также переопределить метод equals\n```\npublic class Point3D extends Point {\n    private int z;\n\n    public Point3D(int x, int y, int z) {\n        super(x, y);\n        this.z = z;\n    }\n\n    public boolean equals(Object obj) {\n        if (super.equals(obj)) {\n            /*\n             * строки не нужны: эти проверки выполняется в базовом классе\n             * if (this == other) return true; \n             * if (other == null) return false;\n             * if(this.getClass() != other.getClass()) return false; \n             */\n            Point3D p3d = (Point3D) obj;\n            if (p3d.z == this.z)\n                return true;\n        }\n        return false;\n    }\n}\n```\n"}, {"votes": "4", "text": "Прошу пояснить код. В частности, вот эту строку\n```\nif (!super.equals(other)) return false;\n```\nОсновной вопрос состоит в следующем. Как Вы думаете, что делает эта строчка процитированного кода? Да, там вызывается метод equals родительского класса. А кто у нас у класса в данном случае родитель? Если верить спецификации, то это java.lang.Object. Значит сначала мы в первой строке Вашего кода вызываем метод equals класса Object. Как Вы думаете, что он делает? Вроде как это известная информация, но для большей достоверности вот цитата из исходников\n```\npublic boolean equals(Object obj) {\n    return (this == obj);\n}\n```\nТо есть он возвращает true только в том случае, когда у нас ссылки на объект совпадают. Если же у нас 2 отдельных объекта, которые хранятся в памяти в разных местах (пусть у них содержимое одинаковое), ссылки на них не совпадают! А что это значит? Это значит, что благодаря строке \nИ ещё заметка относительно \nОбратное утверждение не верно.\nна самом деле в контракте, найти можно - \n"}]},
{"title": "Как работать с svn через HTTP прокси на Ubuntu?", "posts": [{"votes": "8", "text": "При попытке извлечения кода svn выдает следующую ошибку:  \n```\nsvn: OPTIONS of 'http://...': Не удалось разрешить имя хоста `...': \nHost not found (http://...)\n```\n"}, {"votes": "8", "text": "Нужно прописать параметры прокси в настройках svn.\n```\nsudo nano /etc/subversion/servers\n[global]\nhttp-proxy-host = defaultproxy.whatever.com\nhttp-proxy-port = 7000\n```\n"}]},
{"title": "Jar файл в Intellij Idea", "posts": [{"votes": "2", "text": "Не подскажите, как создать jar-файл через UI Intellij Idea (JetBrains)?\n"}, {"votes": "4", "text": "Завит от того, какая версия \nДо 9.0 идём \nВ \nВ 10 не знаю, но, скорее всего, также должно быть. \nА вообще для таких вещей есть \n"}, {"votes": "3", "text": "Пошаговая инструкция:\n >>> \n\nЗатем заходим во вкладку \n"}]},
{"title": "Как завершить процесс в ubuntu?", "posts": [{"votes": "6", "text": "Как завершить процесс в ubuntu?\n"}, {"votes": "8", "text": "Надо запустить терминал и выполнить команду \n```\nkill process_id\n```\nгде process_id - это номер процесса. Этот номер можно получить с помощью команды \n```\nps\n```\n"}, {"votes": "6", "text": "Вариант 1) В терминале вводите\nsudo killall -9 название процесса\nВариант 2) В терминале вводите\nsudo apt-get install htop\nВообще существует множество вариантов и манов на этот счет, я привел Вам более популярные\n"}, {"votes": "4", "text": "Только не всегда процесс убъётся таким образом! По хорошему, лучше использовать\n\nлибо по названию процесса\n\n"}, {"votes": "2", "text": "По хорошему процесс следует завершать сигналом 2(SIGINT) или 15(SIGTERM) и если уж не помогает тогда 9(SIGKILL).\nСигнал 2 посылается программе связанной с терминалом при нажатии Ctrl+C, есть ещё запасная комбинация Ctrl+\\, посылающая сигнал 3(SIGQUIT), который, если не перехватывается, делает дамп памяти процесса (чтобы потом посмотреть в отладчике).\nСигнал 15 посылается процессам при завершении работы системы или смены runlevel и по-умолчанию если не указан другой в командах kill и killall, по нему программа может быстренько сохранить важные данные и удалить временные файлы, если настроит перехват. Так же перехват сигнала 2 используется для завершающих действий перед выходом.\nСигнал 9 нельзя перехватить, поэтому его следует использовать в крайних случаях, когда программа зависла и не реагирует на обычные сигналы.\n"}, {"votes": "1", "text": "pkill \"<шаблон>\"\nУбьет все процессы с таким именем\n"}, {"votes": "-4", "text": "Убиваем процесс -9 убивает железно :)\n```\nkill -9 PID\n```\n"}]},
{"title": "Вызов неуправляемого кода из управляемого", "posts": [{"votes": "3", "text": "Есть необходимость вызвать функцию WinAPI из кода на C#. Какие средства языка позволяют это сделать?\n"}, {"votes": "5", "text": "Есть разные подходы. \nНапример, если использовать P/Invoke из C#, то это выглядит так:\n```\nusing System;\nusing System.Runtime.InteropServices;\n\nnamespace Sample\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            MessageBox(IntPtr.Zero, \"Hello, World!\", \"\", 0);\n        }\n\n        [DllImport(\"user32.dll\", CharSet = CharSet.Auto)]\n        static extern int MessageBox(IntPtr hWnd, String message, String caption, int options);\n    }\n}\n```\n"}]},
{"title": "Какая временная сложность поиска в std::deque?", "posts": [{"votes": "1", "text": ""}, {"votes": "2", "text": "Необходимо учитывать не только контейнер, но и алгоритм. Если рассматривать наихудший случай, то для поиска элемента необходимо обойти весь контейнер, т.е сложность O(n). Если элементы контейнера отсортированы, то  можно использовать бинарный поиск, он даст сложность O(ln(n)).\n"}]},
{"title": "Как получить чистый исполняемый двоичный файл на Linux?", "posts": [{"votes": "1", "text": "Например, есть C код:\n```\nstatic int add(a, b) {\n    return a + b;\n}\n```\nКак скомпилировать этот код в бинарный файл, который будет исполняться с начала файла байт за байтом?\n"}, {"votes": "1", "text": "Для этого можно использовать утилиту \n```\n$ gcc -c sample.c\n$ objcopy -O binary sample.o sample.bin\n```\n"}]},
{"title": "Ошибка использования указателей", "posts": [{"votes": "0", "text": "Почему при компиляции кода:\n```\nchar *first, second;\n\nsecond = first;\n```\nвозникает предупреждение:\n```\n*warning: assignment makes integer from pointer without a cast*\n```\n"}, {"votes": "3", "text": "Судя по строке\n```\nfirst = second;\n```\nнеобходимо определить два указателя и присвоить значение одного из них другому. В C определение вида\n```\nchar *pointer;\n```\nзадает указатель на char, а определение вида\n```\nchar variable;\n```\nзадает переменную типа char. Чтобы определить два указателя на char нужно изменить код.\n```\nchar *first, *second;\n\nfirst = second;\n```\n"}]},
{"title": "Глобальные переменные в Python: сохранить локальную переменную от вызова к вызову функции", "posts": [{"votes": "14", "text": "У меня есть функция, которой необходимо сохранять значение от вызова к вызову, при этом это значение используется только в этой функции. Как правильно использовать глобальные переменные в Python? Я пробовал написать нечто подобное:\n```\nsomeGlobalVar = 0\n\ndef incrimentGlobalVar()\n    someGlobalVar = someGlobalVar + 1\n```\nНо данный код не работает. Может есть другие способы решения данной задачи?\n"}, {"votes": "36", "text": "Есть несколько способов реализовать подобное поведение. \n\nПервое, что может прийти в голову, это использовать глобальные переменные.\n```\ndef func1():\n    print(x)\n\nx = 10\nfunc1()   # 10\n```\nно простое использование на запись не разрешается:\n```\ndef func2():\n    y = 20    # создаёт локальную переменную, а не изменяет глобальную\n\ny = 10\nfunc2()\nprint(y)      # 10\n```\nБолее того, при попытке обратиться к переменной сначала на чтение, потом на запись, мы получим ошибку:\n```\ndef func3():\n    print(z)\n    z = 20\n\nz = 10\nfunc3()   # UnboundLocalError: local variable 'z' referenced before assignment\n```\nЭто происходит из-за того, что использование присваивания переменной \nАналогичный пример как раз приведён в вашем вопросе. Там тоже переменная \n\nДля того, чтобы этот пример работал, необходимо предварительно пометить переменную, как \n```\ndef func4():\n    global w\n    print(w)\n    w = 20\n\n\nw = 10\nfunc4()    # 10\nprint(w)   # 20\n```\nАналогично будет работать и в вашем случае.\n\n\nВторой способ, который может прийти в голову, это использование объекта функции для хранения состояния функции.\n```\ndef func5():\n    if not hasattr(func5, '_state'):  # инициализация значения\n        func5._state = 0\n    print(func5._state)\n    func5._state = func5._state + 1\n\n\n# до первого вызова функции значение не установлено\n# print(func5._state)  # AttributeError: 'function' object has no attribute '_state'\nfunc5()                # 0\nprint(func5._state)    # 1\n```\nВ этом способе удобно то, что значение ассоциировано с самой функцией.\nСтоит быть осторожным, давая имена подобным полям функции, так как в Python 2 у функции есть стандартные поля с названиями, не начинающимися с двух подчёркиваний, например, \n\n\nТретий способ заключается в создании класса с поведением функции. Это наиболее удобный и безопасный, по моему мнению, способ реализации подобного поведения. Просто создайте класс и перегрузите его метод \n```\nclass FuncCreator:\n    def __init__(self, start_state):\n        self.state = start_state\n\n    def __call__(self):\n        print(self.state)\n        self.state += 1\n\n\nfunc6 = FuncCreator(0)\nprint(func6.state)  # 0\nfunc6()             # 0\nprint(func6.state)  # 1\n```\nЭто увеличивает объём кода, но добавляет удобств от использования функциональности класса.\n\n\nЧетвёртый способ заключается в том, чтобы создать функцию, у которой будет необязательный параметр, использующий изменяемое значение в качестве состояния:\n```\ndef func7(state=[]):\n    if not state:\n        state.append(0)\n    print(state[0])\n    state[0] += 1\n\n\nfunc7()  # 0\nfunc7()  # 1\n```\nВ качестве объекта состояния можно использовать любой изменяемый объект. Это использует то, что все значения по умолчанию присваиваются один раз.\n\n\nЕсли вернуться к исходному примеру, то для подсчёта числа вызовов функции будет также может быть удобно использовать декораторы. Это позволит в том числе и переиспользовать код.\nДля Python 3 код может выглядеть, например, так:\n```\nfrom functools import wraps\n\n\ndef call_count(func):\n    count = 0\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        nonlocal count\n        count += 1\n        func(*args, **kwargs)\n        print(count)\n    return wrapper\n```\nВ Python 2 нет \n```\nfrom functools import wraps\n\n\ndef call_count(func):\n    count = [0]\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        count[0] += 1\n        func(*args, **kwargs)\n        print(count[0])\n    return wrapper\n```\nИспользоваться это будет следующим образом:\n```\n@call_count\ndef f():\n    pass\n\nf()  # 1\nf()  # 2\n```\nПри желании вы можете скомбинировать этот способ с каким-нибудь из описанных ранее.\n\nИз всех выше упомянутых способов я бы рекомендовал использовать классы (так как функция с изменяющимся состоянием уже больше похожа на класс, чем на функцию) или поле функции, в случае необходимости быстрого добавления функциональности в код. \n"}, {"votes": "11", "text": "Если глобальная переменная изменяется в функции, ее необходимо объявить.\n```\nsomeGlobalVar = 0\n\ndef incrimentGlobalVar()\n    global someGlobalVar\n    someGlobalVar = someGlobalVar + 1\n```\nЕсли глобальная переменная используется только для чтения, то ее не нужно объявлять.\n```\ndef print_someGlobalVar():\n    print someGlobalVar\n```\nДля сохранения контекста лучше не использовать глобальные переменные. Что именно использовать, надо смотреть по обстоятельствам.\n"}, {"votes": "6", "text": "Глобальные переменные - зло, лучше сделать так:\n```\ndef incrimentGlobalVar():\n    incrimentGlobalVar._someVar = incrimentGlobalVar._someVar + 1 if hasattr(incrimentGlobalVar, \"_someVar\") else 0\n```\n"}, {"votes": "4", "text": "В Питоне 3 можно использовать nonlocal с  \n```\ndef make_counter():\n    i = 0\n    def counter(): # counter() is a closure\n        nonlocal i\n        i += 1\n        return i\n    return counter\n\nincrement = make_counter()\nprint(increment(), increment())  # -> 1 2\n```\nНа более ранних версиях можно было эмулировать nonlocal, используя изменяемый параметр:\n```\ndef increment(counter=[0]):\n    counter[0] += 1\n    return counter[0]\n\nprint increment(), increment()  # -> 1 2\n```\nМожно явный объект использовать:\n```\nimport functools \nimport itertools\n\nincrement = functools.partial(next, itertools.count(1))\n```\nЗдесь используется \n```\ndef count(i=0):\n    while True:\n        yield i \n        i += 1\n```\n"}]}